{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\froman\fcharset0 Times-Roman;\f1\fmodern\fcharset0 Courier;\f2\fswiss\fcharset0 Helvetica;
\f3\fmodern\fcharset0 Courier-Bold;}
{\colortbl;\red255\green255\blue255;\red230\green230\blue230;}
{\*\expandedcolortbl;;\csgray\c92143;}
\margl1440\margr1440\vieww17520\viewh15300\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b\fs48 \cf0 Storing PDS4 versioned hierarchies in a UNIX filesystem
\b0\fs28 \
\
The PDS4 standard defines a hierarchy for groupings of files into bundles, collections, and products.   Bundles are the top-level components and contain collections.  Collections in turn contain products.  \
\
The obvious way to store such a hierarchy into a UNIX filesystem would be to create a directory corresponding to each component.  The bundle directory would contain the directories for its collections, and a collection directory would contain directories for its product.\
\
PDS4 also allows each of these components to be versioned.  This causes problems.\
\

\b\fs36 The problem with versioning directories
\b0\fs28 \
\
Say we have a bundle 
\f1 b
\f0 , which contains a collection 
\f1 c
\f0 , which has three products, 
\f1 pA
\f0 , 
\f1 pB
\f0 , and 
\f1 pC
\f0 .  All are on version 1.  If we store them in the naive way, we have:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f2\fs24 \cf0 {{\NeXTGraphic orig.jpg \width5500 \height5020
}¬}\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf0 \

\f0 \

\fs28 So far, so good.  Say now that 
\f1 pA
\f0  gets updated to version 2.  We update 
\f1 pA
\f0 , which requires updating of 
\f1 c
\f0  and 
\f1 b
\f0  to new versions too.  The new hierarchy looks like this:\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f2\fs24 \cf0 {{\NeXTGraphic modified.jpg \width14600 \height5020
}¬}\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\fs24 \cf0 \

\fs28 Oh no! We\'92ve created duplicate copies (in red) of two products: 
\f1 pB_v1
\f0  and 
\f1 pC_v1
\f0 .  Given the size of the data files we work with, this is a serious problem.  With multiple versions, the redundant copies of data could grow exponentially.  This way of storing files is a non-starter.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\b\fs36 \cf0 One possible solution
\b0\fs28 \
\
The problem is that things need to live in more than one directory at the same time.\
\
This is not a common case in UNIX, but there 
\i is
\i0  a facility to handle it: 
\i filesystem links
\i0 .  Using links for our running example, we end up with this hierarchy:\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f2\fs24 \cf0 {{\NeXTGraphic links.jpg \width9640 \height5020
}¬}\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs28 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf0 \
where the dotted blue lines are filesystem links.\
\
This would be a clean solution to our problem except for one point: maintainability.  Or rather, 
\i repairability
\i0 .\
\
If the software pipeline works flawlessly, we have no problem, but if the pipeline misfunctions and someone needs to repair the hierarchy by hand or if a manual update is required, it would be a terrible job.  Links in UNIX are not common and the standard filesystem tools like 
\f1 ls
\f0  normally ignore the distinction between links and files.  \
\
This is usually what you want, but if someone needs to check and repair the hierarchy, or update to a new version manually, this difficulty in distinguishing links and files would make repairing or reorganizing the hierarchy tedious and error-prone at best, a nightmare at worst.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\b\fs36 \cf0 A more maintainable solution
\b0\fs28 \
\
If we sacrifice some of the elegance of the previous link-based solution, we can arrive at a more complex but easily repairable solution.  \
\
We no longer use the UNIX filesystem hierarchy to reflect the PDS4 containment hierarchy, where subdirectories are used for subcomponents.  Instead we use it to reflect the structure of PDS4 
\i LIDVID
\i0 s (versioned identifiers).  LIDVIDs contain a logical ID followed by a version number.  In our running example, the LIDVID for version1 of 
\f1 pA
\f0  would be 
\f1 urn:nasa:pds:b:c:pA::1
\f0 .  The 
\f1 urn:nasa:pds:
\f0  at the start is essentially boilerplate; the part that varies and is significant is the 
\f1 b:c:pA::1
\f0 .  Using this solution, the product\'92s files would be stored at the filepath 
\f1 b/c/pA/v$1
\f0 .  \
\
Note the simple translation from LIDVID to filepath.  Manually adding products is as simple as translating the LIDVIDs to filepaths and moving the files there.\
\
The filesystem hierarchy now looks like this:\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f2\fs24 \cf0 {{\NeXTGraphic hierarchy.jpg \width11260 \height6940
}¬}\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs28 \cf0 Note that the directories with component names like 
\f1 b
\f0 , 
\f1 c
\f0 , and 
\f1 pB
\f0  (in black), serve only a structural purpose.  Datafiles are stored only in version directories (in blue), which makes sense because PDS files are always part of a versioned component.\
\
(Incidentally, dollar signs are not legal in PDS4 identifiers\'97LIDVIDs, filenames or directory names\'97so our version directories cannot be confused for a directory with a component name.)
\f2\fs24 \
\

\f0\fs28 We still need to store the containment information: how do we know which PDS4 versioned components live within another component?\
\
Rather than using the filesystem hierarchy to store that information, we explicitly store it in a textfile using a simple format (see below).  Each version directory contains a file named 
\f1 subdir$versions.txt
\f0  which gives the names of the subcomponents and their version numbers.  (The version directory will also hold files belonging to that version of that subcomponent.)\
\
Showing the 
\f1 subdir$versions.txt
\f0  files explicitly and the containment information they store, the hierarchy looks like this:\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f2\fs24 \cf0 {{\NeXTGraphic versions.jpg \width10880 \height9820
}¬}\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs28 \cf0 The dashed gray lines indicate component containment.  (For instance, 
\f1 b:c::2
\f0  contains 
\f1 b:c:pA::2
\f0 , 
\f1 b:c:pB::1
\f0 , and 
\f1 b:c:pC::v1
\f0 .)  But we know this because it says so in the 
\f1 b/c/v$2/subdir$versions.txt
\f0  textfile.  Note that the filesystem structure doesn\'92t reflect this information; you know it only by reading the contents of 
\f1 subdir$versions.txt.
\f0 \
\
Although it takes a few more steps than the link-based solution to find out which components contain which subcomponents, it is far easier for a human to write or change.  During development of new\'97and therefore untested by time\'97software, this trade-off seems worthwhile.
\f2\fs24 \
\

\f0\b\fs36 The 
\f3 subdir$versions.txt
\f0  file format
\b0\fs28 \
\
The format of the 
\f1 subdir$versions.txt
\f0  file is very simple.  It consists of a series of lines in ASCII text.  Each line consists of a subgrouping (subdirectory) name followed by a space and its version number.  That\'92s it.  So parsing is trivial.\
\
In our running example, 
\f1 b/v$1/subdir$versions.txt
\f0  consists of the single line \
\
\pard\tx720\tx722\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1 \cf0 \cb2 c 1\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0 \cf0 \cb1 \
This indicates that version 1 of the bundle 
\f1 b
\f0  contains a single collection 
\f1 c
\f0  and the collection\'92s version number is 1.\
\
Again, 
\f1 b/c/v$2/subdir$versions.txt
\f0  contains three lines\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1 \cf0 \cb2 pA 2\
pB 1\
pC 1\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0 \cf0 \cb1 \
indicating that the version 2 of collection 
\f1 c
\f0  contains three products, 
\f1 pA
\f0 , 
\f1 pB
\f0 , 
\f1 pC
\f0  with versions 2, 1, and 1 respectively.\
\
The format is so simple, it should not be difficult for humans to hand-hack the files, if necessary.\
\

\b\fs36 Software and versioned files
\b0\fs28 \
\
Software is better than humans at handling well-defined, repetitive tasks, so the extra complexity of our last solution presents little problem in practice.\
\
In the PDART pipeline software, we introduce an extra layer of software between the pipeline and the actual UNIX filesystem.  This layer is a 
\i virtual filesystem
\i0 , written using 
\f1 pyfilesystem
\f0 .  When we want to read (or write) a file, instead of calling the Python standard 
\f1 os.read()
\f0  or 
\f1 os.write()
\f0 , we call 
\f1 fs.read()
\f0  or 
\f1 fs.write()
\f0 .  This extra layer of software can translate filepaths on the fly as necessary to make the filesystem hierarchy look like any other hierarchy.  \
\
By writing different virtual filesystems, we can encapsulate the complexity of our last solution into one place in the software.  The rest of the software can pretend that the files are laid out in the most convenient way for it, depending on the virtual filesystem to translate.\
\
For example, we have a virtual filesystem that\'97given a bundle version and our complex-but-repairable UNIX filesystem hierarchy\'97makes it look as if you only have one version of the bundle and it\'92s laid out like in our original diagram at the top of this paper, with subdirectories exactly corresponding to subcomponents.  To deliver a version of a bundle to a customer, we could just 
\f1 tar
\f0  up this view on the directory tree and they would get the exact files for this bundle version.\
\
Using software like 
\f1 FUSE
\f0 , it\'92s even possible to mount virtual filesystems in the OS so a user could see a translated version of the filesystem in the Finder.  This is out of the scope of our current project, but suggests the power of using virtual filesystems.\
\

\f1 pyfilesystem
\f0 : http://pyfilesystem2.readthedocs.io/en/latest/\

\f1 FUSE
\f0 : https://en.wikipedia.org/wiki/Filesystem_in_Userspace\
}